Treasure & Score

To give our game some replayability, we'll add a high score mechanic. The player will pick up a treasure to gain a point, but doing so will spawn another monster. A boolean flag will suffice to denote a tile with treasure on it and we'll spawn 3 treasures on each level. And we need a new global variable *score* that resets to 0 for each game.

[draw treasure sprite]

-------------------------------------- map.js
function generateLevel(){
	tryTo('generate map', function(){
		return generateTiles() == randomPassableTile().getConnectedTiles().length;
	});
	generateMonsters();

	for(let i=0;i<3;i++){															//ADD
		randomPassableTile().treasure = true;										//ADD
	}																				//ADD
}
-------------------------------------- 

-------------------------------------- game.js
function startGame(){	
	level = 1;
	score = 0;																		//ADD
	startLevel(startingHp);
	
	tick();
	gameState = "running";
}
-------------------------------------- 

-------------------------------------- tile.js

draw(){
	drawSprite(this.sprite, this.x, this.y);

	if(this.treasure){																//ADD
		drawSprite(12, this.x, this.y);												//ADD
	}
}

...

class Floor extends Tile{
	constructor(x,y){
		super(x,y, 2, true);
	};

	stepOn(monster){
		if(monster.isPlayer && this.treasure){										//ADD
			score++;
			this.treasure = false;
			spawnMonster();
		}
	}
}
-------------------------------------- 

And now that we wrote our drawText function, showing our current score is pretty easy. The calls to draw the current level and current score only differ by text and Y position, which we're manually hardcoding.

---------------------------------- game.js
function draw(){
	if(gameState == "running" || gameState == "dead"){
		ctx.clearRect(0,0,canvas.width,canvas.height);

		for(let i=0;i<numTiles;i++){
			for(let j=0;j<numTiles;j++){
				tiles[i][j].draw();
		    }
		}
		
		for(let k=monsters.length-1;k>=0;k--){
			monsters[k].draw();
		}
		player.draw();

		drawText("Level: "+level, 30, false, 40, "violet");
		drawText("Score: "+score, 30, false, 70, "violet");					//ADD
	}
}
--------------------------------------

If we have a score, we certainly need a high score board. The following additions add a score array to a browser storage mechanism called localStorage, which we'll then retrieve and display on the title screen. The reason we're using localStorage is to preserve scores across page refreshes and browser launches.

Since everything you put in localStorage needs to be a string, we're converting back and forth from JSON. If you don't know JSON, not to worry! It's simply a data format that looks much like JavaScript and all you need to utilize it is two built in functions.

First let's grab the scores, whether there's some there or not.

----------------------------------  game.js
function getScores(){
	if(localStorage["scores"]){
		return JSON.parse(localStorage["scores"]);
	}else{
		return [];
	}
}
----------------------------------

If we've not yet saved anything to localStorage, we simply return an empty array. But if we have, we take what's there, parse it as JSON, and return the result.

Now let's write the function to add a score.

---------------------------------- game.js
function addScore(score, won){
	let scores = getScores();
	let scoreObject = {score: score, run: 1, totalScore: score, active: won};
	let lastScore = scores.pop();

	if(lastScore){
		if(lastScore.active){
			scoreObject.run = lastScore.run+1;
			scoreObject.totalScore += lastScore.totalScore;
		}else{
			scores.push(lastScore);
		}
	}
	scores.push(scoreObject);

	localStorage["scores"] = JSON.stringify(scores);
}
----------------------------------

In this game you'll be able to continue a high score if you won the last game. This lets you attempt win streaks, a common thing to find in broughlikes.

So what we're doing here is: retrieving our scores and either continuing it (if it was still active) or adding a new score to our array. The last line does the actual work of storing the score array again.

We'll call this function in two cases: losing and winning.

---------------------------------- game.js
function tick(){
	for(let k=monsters.length-1;k>=0;k--){
		if(!monsters[k].dead){
			monsters[k].update();
		}else{
			monsters.splice(k,1);
		}
	}

	if(player.dead){
		addScore(score, false);										//ADD
		gameState = "dead";
	}

	spawnCounter-=2;
	if(spawnCounter <= 0){
		spawnMonster();
		spawnCounter = spawnRate;
		spawnRate--;
	}
}
---------------------------------- 

---------------------------------- tile.js
class Exit extends Tile{
	constructor(x, y){
		super(x, y, 4, true);
	}

	stepOn(monster){
		if(monster.isPlayer){
			if(level == numLevels){
				addScore(score, true);								//ADD
				showTitle();
			}else{
				level++;
				startLevel(Math.min(maxHp, player.hp+1));
			}
		}
	}
}
----------------------------------

Our high scores are now quietly sitting in localStorage. You can check for yourself by simply typing "localStorage" into the console or taking a peek at the Application tab in the dev tools.

Let's display them.

---------------------------------- game.js
function showTitle(){
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    drawText("SUPER", 40, true, canvas.height/2 - 110, "white");
	drawText("BROUGH BROS.", 70, true, canvas.height/2 - 50, "white");

	drawScores();																//ADD

	gameState = "title";
}

...

function drawScores(){															//ADD
	let scores = getScores();
	if(scores.length){
		drawText(
			rightPad(["RUN","SCORE","TOTAL"]),
			18,
			true,
			canvas.height/2,
			"white"
		);

		let newestScore = scores.pop();
		scores.sort(function(a,b){
			return b.totalScore - a.totalScore;
		});
		scores.unshift(newestScore);
		for(let i=0;i<Math.min(10,scores.length);i++){
			let scoreText = rightPad([scores[i].run, scores[i].score, scores[i].totalScore]);
			drawText(
				scoreText,
				18,
				true,
				canvas.height/2 + 24+i*24,
				i == 0 ? "aqua" : "violet"
			);
		}
	}
}
----------------------------------

Don't panic. You could draw the scores in MUCH less code if you prefer, but we're taking our time to carefully sort and align the scores here. And it's also artificially long because we've split drawText arguments onto multiple lines for clarity.

Let me break it down:

-We get the scores and then only continue if we have some
-We draw a header row (RUN SCORE TOTAL) in the very middle of the canvas
-Next we take the most recent score off the end, sort the scores in descending order, and put that most recent score back at the beginning. This way you always see the last score at the top and in a different color (accomplished a few lines down by [i == 0 ? "aqua" : "violet"]).
-We loop over at most 10 scores and draw each one slightly lower on the screen with [canvas.height/2 + 24+i*24]

You'll notice a new utility function called rightPad. We're adding this so the scores are spaced out in a table format.

---------------------------------- util.js
function rightPad(textArray){
	let finalText = "";
	textArray.forEach(text => {
		text+="";
		for(let i=text.length;i<10;i++){
			text+=" ";
		}
		finalText += text;
	});
	return finalText;
}
----------------------------------

We iterate over an array of strings representing a row of data. We pad out each string with spaces until it is 10 characters long and add it to the last string. We return the combined string, which should be a perfectly spaced out row of score data.

The next section adds some nifty animation and screenshake.