Drawing to the screen

You should already everything you need installed: a browser (e.g. Firefox), a text editor (e.g. Notepad), and an image editor (e.g. Paint). However, the apps that I'm going to use and that I recommend are Google Chrome, Sublime Text, and GIMP.


First open your text editor and create a file called *index.html*, type in "Hello, World!", and save the file.

--------------------------------------
Hello, World!
--------------------------------------

Open the file in your chosen browser

Be aware that this isn't valid HTML but the browser will render it just fine anyway.

These next 6 lines are all you need to draw to the screen:

--------------------------------------
<canvas></canvas>
<script>
	canvas = document.querySelector("canvas");
	ctx = canvas.getContext("2d");
	ctx.fillRect(0,0,20,20,20);
</script>
--------------------------------------

There's our player character! But the player doesn't move. Replace the fillRect line with the following code:

--------------------------------------
<script>
	canvas = document.querySelector("canvas");
	ctx = canvas.getContext("2d");
	ctx.fillRect(0,0,20,20,20);												//DELETE (moved below)

	x = y = 0;																//EVERYTHING ADDED EXCEPT </script>

	document.querySelector("html").onkeypress = function(e){
	    if(e.key=="w") y--;
	    if(e.key=="s") y++;
	    if(e.key=="a") x--;
	    if(e.key=="d") x++;
	};

	function draw(){
	    ctx.fillRect (x*20,y*20,20,20);
	}

	setInterval(draw, 15);
</script>
--------------------------------------
-Nice, we sort of made an etch-a-sketch. Note that these keycodes only correspond to lower case values. If you turn on caps lock, the game will suddenly stop responding.


Let's clear the canvas at the beginning of every draw call.


--------------------------------------
	function draw(){
		ctx.clearRect(0,0,1000,1000);										//ADD
	    ctx.fillRect (x*20,y*20,20,20);
	}
--------------------------------------

In 20 lines of code, we have a moving player. We're 90% of the way to having a functioning game. :D

One problem is the canvas is not aligned properly and we don't know where it ends. Let's add an outline and center the canvas. To do this, we're going to add a style tag and put our CSS in it. If we had a lot of CSS, it would be better to put it in a separate file but the small amount we need fits well in the document.

--------------------------------------
<style>
	canvas{
		outline: 1px solid white;
	}

	body{
		background-color: seagreen;
		text-align: center;
		margin-top: 50px;
	}
</style> 
--------------------------------------


A couple more lines at the top to make this truly valid HTML. The doctype tells the browser we're an HTML page, duh. And a title is required for... reasons. By the way, you might be used to html, head, and body tags but they're actually optional. Include them if you'd like.

--------------------------------------
<!DOCTYPE html>
<title>AWESOME BROUGHLIKE</title>
--------------------------------------

Let's lay the groundwork for the rest of the project by creating a couple folders and empty files. Keep in mind, this is only to help us stay organized. There's no requirement to have a specific directory layout. If we keep all of our code in one file, it'll get really hard to dig through. It's certainly not impossible. I know a major roguelike project that consists of a single 80,000 line python file.

Create a folder called "js" where all our script files will go and one called "sounds" where our sounds will go.

Go ahead and create six JavaScript files in the new js folder:

game.js
map.js
tile.js
monster.js
util.js
spell.js


We'll need to include these files in our index.html.

--------------------------------------
<canvas></canvas>

<script src="js/game.js"></script>						//ADD ALL SCRIPT TAGS
<script src="js/map.js"></script>
<script src="js/tile.js"></script>
<script src="js/monster.js"></script>
<script src="js/util.js"></script>
<script src="js/spell.js"></script>

<script>
--------------------------------------


I'm defining all of these functions globally and without using any sort of namespacing or modules. This makes the code shorter, but potentially harder to track down. One easy alternative is defining the entire file an object like this:

--------------------------------------
	game = {
		someFunction: function(){
			...
		},
		anotherFunction: function(){
			...
		},
		andAnother: function(){

		}
	}
--------------------------------------

Then you can call "game.someFunction()" and know exactly where to find it. For now, I'm going to stick to global functions.

*Move* our canvas and ctx definitions to a new function in game.js called setupCanvas.

We want to dynamically size the canvas based on some constants.  This will make it really easy to tweak the design of the game later.

-------------------------------------- game.js
function setupCanvas(){
	canvas = document.querySelector("canvas");
	ctx = canvas.getContext("2d");

	canvas.width = tileSize*(numTiles+uiWidth);
	canvas.height = tileSize*numTiles;
	canvas.style.width = canvas.width + 'px';
	canvas.style.height = canvas.height + 'px';
	ctx.imageSmoothingEnabled = false;
}
--------------------------------------

Add a call to this method at the bottom of the script tag:

--------------------------------------
setupCanvas();
--------------------------------------

Run the code.

You should get an error. Also take a glance at the Source tab in the dev tools, where we can start debugging this issue.

We forgot to define a few variables. Let's do that now in the original script tag in index.html:


--------------------------------------
	let tileSize = 64;
	let numTiles = 9;
	let uiWidth = 4;
--------------------------------------

That should fix the error we saw. Now we can also utilize some of these variables in the draw call.

You'll notice that the "player" rectangle gets bigger and when you move to the bottom/edge of the screen, it lines up nicely.

--------------------------------------
		ctx.clearRect(0,0,canvas.width,canvas.height);
	    ctx.fillRect (x*tileSize,y*tileSize,tileSize,tileSize);
--------------------------------------

Finally, let's replace our little rectangle with a real sprite. You could make the whole game in rectangles if you wanted (it worked for Mike Bithell), but I'm not talented enough for that. I'm going to use GIMP.

Open up your favorite image editor. Make a rectangle that's 512 by 16 pixels. Normally, a spritesheet is arranged in big square
but it works just as well and more simply as a long line of sprites.

Draw your character in the first 16x16 pixels, your character corpse in the next, and export the file to your project folder.

Add the following code to your script block. This will load the PNG file.

--------------------------------------
	let spritesheet = new Image();
	spritesheet.src = 'spritesheet.png';
--------------------------------------

We're going to replace our "fillRect" call with a "drawImage" call.

Let's try the simplest way to call drawImage with 3 images.

--------------------------------------
	ctx.drawImage(spritesheet, x*tileSize, y*tileSize);
--------------------------------------

It works, but there's a few problem. The sprites are too small for one. The bigger problem though is that this displays the *whole* spritesheet. We need to call drawImage with 9 arguments.

It sounds bad, but it's pretty simple once you see the purpose. The first argument is the name of the image. The last four arguments are totally identical to the ones we used in drawRect. Those specify how to draw to the *destination* on screen. But we're using a spritesheet which will eventually consist of many sprites. We can't use the whole image, so we need 4 more arguments to specify how to pull from the *source*.

One image, 4 source variables, and 4 destination variables.

void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

[reference mozilla page]  https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage 


-Since we're going to be making this same call repeatedly, let's move this code out to a function called drawSprite in game.js and move the draw function too. And let's put each argument on a different line to make it clearer.

--------------------------------------	game.js
function drawSprite(sprite, x, y){
	ctx.drawImage(
		spritesheet,
		sprite*16,
		0,
		16,
		16,
		x*tileSize,
		y*tileSize,
		tileSize,
		tileSize
	);
}

function draw(){
	ctx.clearRect(0,0,canvas.width,canvas.height);
	drawSprite(0, x, y);
}
--------------------------------------

Now one more hiccup. Our sprite looks like poop. The reason is the way browser scales images by default. It makes sene for photos but not for pixel art. For years, displaying scaled pixel art in browsers was basically impossible. Luckily we only need one line to correct it now, placed at the end of our setupCanvas() function:

--------------------------------------
ctx.imageSmoothingEnabled = false;
--------------------------------------

And we're done! If you're feeling a little overwhelmed by all these arcane references to interacting with the DOM, take heart that we're pretty much past all of that. Our entry point into drawing stuff on the screen is to load images, grab a canvas element, get its context, and start calling draw operations on it. A lot of boilerplate right? But the good news is that we don't need any more hooks into the DOM and the rest of the code we write will be fairly self contained.