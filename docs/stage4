Monsters - Part 2

Since the monsters will be attacking the player and vice versa, let's first draw the HP for each.

-------------------------------------- monster.js
draw(){
	drawSprite(this.sprite, this.tile.x, this.tile.y);
	this.drawHp();
}

drawHp(){
	for(let i=0;i<this.hp;i++){
		drawSprite(
			10,
			this.tile.x + (i%3)*(5/16),
			this.tile.y - Math.floor(i/3)*(5/16)
		);
	}
}
-------------------------------------- 

You can see a little bit of funky math here.

-(5/16): Since drawSprite() operates on a sprite index, we normally pass in whole numbers representing 16 pixel sprites but we can work in individual pixels by using fractions. 5/16 means 5 pixels.

-(i%3) ensures we start over from left to right every 3 pips.

-(Math.floor(i,3)" increases by 1 every 3 pips.

The result means pips are drawn first left to right offset by 5 pixels and then stacked vertically offset by 5 pixels.


Now we can let the monsters attack the player and vice verse with a small addition to tryMove. We're comparing "isPlayer" flags to make sure monsters don't attack each other.

We're moving the behavior of attacking and dying to hit() and die(). Pretty straightforward.

When dying, the sprite is set to index 1 (our player corpse). We don't want to draw the player corpse for the other monsters, but it won't matter. We'll  stop drawing those monsters as soon as they're dead.

--------------------------------------  monster.js
tryMove(dx, dy){
	const newTile = this.tile.getNeighbor(dx,dy);
	if(newTile.passable){
		if(!newTile.monster){
			this.move(newTile);
		}else{																			//ADD
			if(this.isPlayer != newTile.monster.isPlayer){								//ADD
				newTile.monster.hit(1);													//ADD
			}																			//ADD
		}
		return true;
	}
}

hit(damage){																			//ADD
	this.hp -= damage;
	if(this.hp <= 0){
		this.die();
	}
}

die(){																					//ADD
	this.dead = true;
	this.tile.monster = null;
	this.sprite = 1;
}
-------------------------------------- 

Attacking is in the game. If you somehow manage to let the monsters kill you, you'll notice that you're still able to move around the map as a corpse. We'll tackle that later.

So Monsters are basically working as expected, but all the same. Here's what I have planned for this tutorial, but feel free to alter the monsters as you see fit and add your own:

Bird: our plain old monster with no special behavior.

Snake: moves twice (yes, basically copied from 868-HACK's Virus).

Tank: moves every other turn

Eater: destroys walls and heals by doing so

Jester: moves randomly

-------------------------------------- monster.js
class Snake extends Monster{
	constructor(tile){
		super(tile, 1, 6);
	}

	doStuff(){															//ADD
		this.attackedThisTurn = false;
		super.doStuff();

		if(!this.attackedThisTurn){
			super.doStuff();
		}
	}
}
--------------------------------------

Rather simple. The Snake can move twice, move and attack, but not attack twice (that's overpowered!).

We need one tie-in within tryMove to set this flag to true upon attacking.

-------------------------------------- monster.js
tryMove(dx, dy){
	const newTile = this.tile.getNeighbor(dx,dy);
	if(newTile.passable){
		if(!newTile.monster){
			this.move(newTile);
		}else{
			if(this.isPlayer != newTile.monster.isPlayer){
				this.attackedThisTurn = true;							//ADD
				newTile.monster.hit(1);
			}
		}
		return true;
}
--------------------------------------

There you go. While testing this code, it may be easier to temporarily modify the spawnMonster code to only generate a specific kind of monster.

For the Tank, we'll introduce a "stunned" flag which we can reuse to stun monsters whenever they are hit by the player.


-------------------------------------- monster.js
tryMove(dx, dy){
	const newTile = this.tile.getNeighbor(dx,dy);
	if(newTile.passable){
		if(!newTile.monster){
			this.move(newTile);
		}else{
			if(this.isPlayer != newTile.monster.isPlayer){
				this.attackedThisTurn = true;
				newTile.monster.stunned = true;							//ADD
				newTile.monster.hit(1);
			}
		}
		return true;
	}
}
...

update(){
	if(this.stunned){													//ADD
		this.stunned = false;
		return;
	}
	this.doStuff();
}

...

class Tank extends Monster{
	constructor(tile){
		super(tile, 3, 7);
	}

	update(){															//ADD
		let startedStunned = this.stunned;
		super.update();
		if(!startedStunned){
			this.stunned = true;
		}
	}
}
--------------------------------------


Then comes the "Eater". Before doing normal monster behavior, this guy is going to check for any nearby walls and eat them. Each wall grants half a health point (our drawHp method only draws whole points though).

We're introducing a replace() method on Tile. You can use this any time one tile type changes into another type. One thing that's not coded here is code to copy over monsters and items present on the old tile to the new tile. Keep that in mind for future additions.

We're adding a heal() method and a constant maxHp to put a ceiling on how much health monsters or the player can acquire.


-------------------------------------- monster.js
class Eater extends Monster{
	constructor(tile){
		super(tile, 1, 8);
	}

	doStuff(){
		let neighbors = this.tile.getAdjacentNeighbors().filter(t => !t.passable && inBounds(t.x,t.y));
		if(neighbors.length){
			neighbors[0].replace(Floor);
			this.heal(0.5);
		}else{
			super.doStuff();
		}
	}
}
--------------------------------------


-------------------------------------- monster.js (add to Monster class)

heal(damage){
	this.hp = Math.min(maxHp, this.hp+damage);
}
-------------------------------------- 
-------------------------------------- tile.js
replace(newTileType){
	tiles[this.x][this.y] = new newTileType(this.x, this.y);
	return tiles[this.x][this.y];
}
-------------------------------------- 

-------------------------------------- index.html 
<script src="js/util.js"></script>
<script src="js/spell.js"></script>

<script>
	const maxHp = 6; 
	
	const tileSize = 64;
	const numTiles = 11;
--------------------------------------


The last monster is the Jester and it requires only an overriden doStuff() method in order to move randomly:

-------------------------------------- monster.js 
class Jester extends Monster{
	constructor(tile){
		super(tile, 9, 2);
	}

	doStuff(){
		let neighbors = this.tile.getAdjacentPassableNeighbors();
		if(neighbors.length){
			this.tryMove(neighbors[0].x - this.tile.x, neighbors[0].y - this.tile.y);
		}
	}
}
--------------------------------------

In the next section we'll turn this thing into a proper game with a title screen, multiple levels, and victory and failure conditions.