Map generation
=============

In this step, we want to generate a map to play on.

[explanation of the grid and multi-dimensional arrays]

Make a new class called Tile in tile.js. You can see that we're also using drawSprite like we did for the player.

The sprite variable is simply an index into the spritesheet. The first sprite 0, the second sprite 1, the third sprite 2
--------------------------------------	tile.js
class Tile{
	constructor(x, y, sprite, passable){
		this.x = x;
		this.y = y;
		this.sprite = sprite;
		this.passable = passable;
	}

	draw(){
		drawSprite(this.sprite, this.x, this.y);
	}
}
--------------------------------------

We're never going to use our Tile class directly, but instead extend it for various purposes.

The minimum you need for a map is a floor tile and a wall tile. These are pretty simple for now and only really differ by their sprite and if they are "passable".

--------------------------------------	tile.js
class Floor extends Tile{
	constructor(x,y){
		super(x, y, 2, true);
	};
}

class Wall extends Tile{
	constructor(x, y){
		super(x, y, 3, false);
	}
}
--------------------------------------


In map.js, we're going add generateLevel() and generateTiles() to start making the map. Call generateLevel() in index.html


--------------------------------------	index.html
generateLevel();
--------------------------------------	map.js
function generateLevel(){
	generateTiles();
}

function generateTiles(){
	tiles = [];
	for(let i=0;i<numTiles;i++){
		tiles[i] = [];
		for(let j=0;j<numTiles;j++){
	    	if(Math.random() < 0.3){
	    		tiles[i][j] = new Wall(i,j);
	    	}else{
	    		tiles[i][j] = new Floor(i,j);
	    	}
	    }
	}
}
--------------------------------------
This makes a multidimensional array called tiles and populates it with about 30% walls and 70% floors.


So our map is actually there and the way you can confirm this is by going into the dev tools and simply typing "tiles".

But let's draw it. All we need to do is iterate over every tile and call draw on it.

But first, I want to wrap access to the tile array in a function called getTile(). There are a lot of reasons for doing this. For one it reads a little cleaner, but it also lets us pull off shenanigans like returning tiles *outside* the bounds of the array (which might happen if, for instance, the player casts a giant area of effect spell that extends past the outer dungeon walls).

-------------------------------------- map.js

function inBounds(x,y){
	return x>=0 && y>=0 && x<numTiles && y<numTiles;
}

function getTile(x, y){
	if(inBounds(x,y)){
		return tiles[x][y];
	}else{
		return new Wall(x,y);
	}
}

--------------------------------------

Now with that, we can get to drawing:

Add this after your ctx.clearRect() call in game.js

-------------------------------------- game.js

for(let i=0;i<numTiles;i++){
	for(let j=0;j<numTiles;j++){
		getTile(i,j).draw();
    }
}

--------------------------------------

Cool.

We haven't added an outer wall though. Let's modify generateTiles() and reuse the inBounds() function to make one.


--------------------------------------
function generateTiles(){
	tiles = [];
	for(let i=0;i<numTiles;i++){
		tiles[i] = [];
		for(let j=0;j<numTiles;j++){
	    	if(Math.random() < 0.3 || !inBounds(i,j)){
	    		tiles[i][j] = new Wall(i,j);
	    	}else{
	    		tiles[i][j] = new Floor(i,j);
	    	}
	    }
	}
}
--------------------------------------

We're not interacting with the tiles though. We start on a wall and we're walking right through them!

To fix that first problem, we're simply going to teleport the player to a random floor tile when the game starts.

How do we find a random floor tile though? One really dumb, easy way to do so is repeatedly grab random tiles until we find a floor tile. This pattern works really well for a variety of map generation techniques: try to do something at random and keep doing it until we get it right. Add a timeout to make sure we don't get stuck in an infinite loop on accident. You don't want to lock up your browser.

And we'll also need a simple utility function to generate random integers within a given range.

-------------------------------------- util.js
function tryTo(description, callback){
	for(let timeout=1000;timeout>0;timeout--){
		if(callback()){
			return;
		}
	}
	throw 'Timeout while trying to '+description;
}

function randomRange(min, max){
	return Math.floor(Math.random()*(max-min+1))+min;
}
-------------------------------------- map.js
function randomPassableTile(){
	let tile;
	tryTo('get random passable tile', function(){
		const x = randomRange(0,numTiles-1);
		const y = randomRange(0,numTiles-1);
		tile = tiles[x][y];
		return tile.passable && !tile.monster;
	});
	return tile;
}
--------------------------------------

[video only: Let's take our "tryTo" out for a spin and generate 99% walls.]

Our map is generated and our player is spawned in the correct place. In the next step, we'll make sure we can't walk through walls and we'll add some enemies.

One more big problem and this one is a super common headache when procedurally generating the maps. With our extremely dumb way of making the levels, there are often areas of the map not connected to other areas. We need a way a check that everything is connected. First let's make a method on Tile called returnConnectedTiles().

First let's some write some psuedocode.

[drawing of grid and algorithm]

--------------------------------------
	returnConnectedTiles(){
		//start with a random passable tile
		//while there are more tiles to check...
			//pick a tile that hasn't been checked
			//get its neighbors
			//filter out the walls
			//filter out the tiles we've already checked
			//add the filtered neighbors to a list of connected tiles and to the tiles that need to be checked
		//return connected tiles
	}
--------------------------------------


We can break this down into a few different methods within our Tile class:

-------------------------------------- tile.js
getNeighbor(dx, dy){
	return getTile(this.x + dx, this.y + dy)
}

getAdjacentNeighbors(){
	return shuffle([
		this.getNeighbor(0, -1),
		this.getNeighbor(0, 1),
		this.getNeighbor(-1, 0),
		this.getNeighbor(1, 0)
	]);
}

getAdjacentPassableNeighbors(){
	return this.getAdjacentNeighbors().filter(t => t.passable);
}

getConnectedTiles(){
	let connectedTiles = [this];
	let frontier = [this];
	while(frontier.length){
		const neighbors = frontier.pop()
							.getAdjacentPassableNeighbors()
							.filter(t => !connectedTiles.includes(t));
		connectedTiles = connectedTiles.concat(neighbors);
		frontier = frontier.concat(neighbors);
	}
	return connectedTiles;
}
-------------------------------------- util.js
function shuffle(arr){
	let temp, r;
    for (let i = 1; i < arr.length; i++) {
        r = randomRange(0,i);
        temp = arr[i];
        arr[i] = arr[r];
        arr[r] = temp;
    }
    return arr;
--------------------------------------

Let's break this down.

**getNeighbor()** is pretty straightforward and it's really useful when coding all sorts of mechanics. Note that it works for more than just nearby neighbors.

**getAdjacentNeighbors()** returns the adjacent neighbors of a tile and shuffles them before returning.

**getAdjacentPassableNeighbors()** additionally filters out non-passable tiles (e.g. walls). Here we're using a "fat arrow" syntax for the function. It looks weird but it's just a function with the argument list on the left of the arrow and function body expression on the right, which will be automatically returned. Filter is a nifty JavaScript array function where we pass in a callback and we return true for only the elements we want to keep.

**getConnectedTiles()** does exactly what the psuedocode described. It uses filter again and also concat, which adds one array to another.

**shuffle()** is an implementation of Fisher-Yates shuffle. All it's doing is a random swap for each element in an array, leading to a perfectly shuffled array.

OK, to finish this up let's count and return how many passable tiles we have in our generateTiles() method. Then we can compare that number to the length of the array returned by getConnectedTiles(). If all of the floor tiles are connected, those numbers should be equal!

If not, we keep retrying just like we did with randomPassableTile().

-------------------------------------- map.js
function generateLevel(){
	tryTo('generate map', function(){
		return generateTiles() == randomPassableTile().getConnectedTiles().length;
	});
}

function generateTiles(){
	let passableTiles=0;
	tiles = [];
	for(let i=0;i<numTiles;i++){
		tiles[i] = [];
		for(let j=0;j<numTiles;j++){
	    	if(Math.random() < 0.3 || !inBounds(i,j)){
	    		tiles[i][j] = new Wall(i,j);
	    	}else{
	    		tiles[i][j] = new Floor(i,j);
	    		passableTiles++;
	    	}
	    }
	}
	return passableTiles;
}
--------------------------------------

So now refresh a bunch of times. You should never again see disconnected "islands".

In the next section we'll create our monsters and check that the player can't walk through walls.