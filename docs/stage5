Game lifecycle: drawing text, title screen, failure condition, and moving between levels


Currently when monsters are killed they are removed from the monsters array using "monsters.splice(k,1);". But there is no code to handle player death. Let's tackle that now.

We'll add the concept of a "gameState" so we can model the game as a state machine with four states:

-"loading": waiting for the assets to load
-"title": on the title screen
-"running": playing the game actively
-"dead": the moment after the player has died, but before returning to the title screen

Add the gameState with an initial value of loading. Our spritesheet imgae has a handler that will be called when it's done loading called onload. We'll set this to a new function showTitle.

The gameState can be used by wrapping particular blocks in conditionals that check for certain states and setting gameState to a new value whenever we want to transition.

[GRAPH OF STATE MACHINE]

We'll be moving some code in index.html to new functions in game.js.

-------------------------------------- index.html
<script>
	const maxHp = 6; 
	const startingHp = 3;												//ADD
	const numLevels = 6;												//ADD
	
	const tileSize = 64;
	const numTiles = 11;
	const uiWidth = 4;

	let level = 1;
	let gameState = "loading";											//ADD
	let player;															//ADD

	let spritesheet = new Image();
	spritesheet.onload = showTitle;										//ADD
	spritesheet.src = 'spritesheet.png';

	document.querySelector("html").onkeypress = function(e){			//UPDATE
	    if(gameState == "title"){										//ADD...
			startGame();												//ADD...
		}else if(gameState == "dead"){									//ADD...
			showTitle();												//ADD...
		}else{															//ADD...
		    if(e.which==119) player.tryMove(0,-1);
		    if(e.which==115) player.tryMove(0,1);
		    if(e.which==97) player.tryMove(-1, 0);
		    if(e.which==100) player.tryMove(1, 0);
		}
	};

	setupCanvas();

	generateLevel();													//DELETE 

	let player = new Player(randomPassableTile());						//DELETE (MOVE ASSIGNMENT TO GAME.JS)

	setInterval(draw, 20);
</script>
--------------------------------------

We only want to draw when the gameState is running or dead.

We'll add three new functions also: showTitle, startGame, and startLevel.

-------------------------------------- game.js
function draw(){
	if(gameState == "running" || gameState == "dead"){							//ADD
		ctx.clearRect(0,0,canvas.width,canvas.height);

		for(let i=0;i<numTiles;i++){
			for(let j=0;j<numTiles;j++){
				tiles[i][j].draw();
		    }
		}
		
		for(let k=monsters.length-1;k>=0;k--){
			monsters[k].draw();
		}
		player.draw();
	}
}

...

function tick(){
	for(let k=monsters.length-1;k>=0;k--){
		if(!monsters[k].dead){
			monsters[k].update();
		}else{
			monsters.splice(k,1);
		}
	}

	if(player.dead){															//ADD		
		gameState = "dead";
	}
}

....

function showTitle(){															//ADD
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

	gameState = "title";
}

function startGame(){															//ADD
	level = 1;
	startLevel(startingHp);
	
	tick();
	gameState = "running";
}

function startLevel(playerHp){													//ADD
	generateLevel();

	player = new Player(randomPassableTile());
	player.hp = playerHp;
}
----------------------------------

Now when you load the game, you'll get a "title screen". For now, it's a dark blank box. When you hit a key, the game will start running. And if you were to die, everything would freeze until you pressed another key... leading back to the title screen.

But it's not easy to die in this game. No monsters spawn after the first two. Let's fix that.

----------------------------------
function tick(){
	for(let k=monsters.length-1;k>=0;k--){
		if(!monsters[k].dead){
			monsters[k].update();
		}else{
			monsters.splice(k,1);
		}
	}

	if(player.dead){
		gameState = "dead";
	}

	spawnCounter-=2;																//ADD
	if(spawnCounter <= 0){														//ADD		
		spawnMonster();
		spawnCounter = spawnRate;
		spawnRate--;
	}
}

...

function startLevel(playerHp){
	spawnRate = 22;																//ADD
	spawnCounter = spawnRate;													//ADD

	generateLevel();

	player = new Player(randomPassableTile());
	player.hp = playerHp;
}
----------------------------------

We're using two new global variables here.

-spawnRate is how often monsters will get spawned
-spawnCounter counts down until the new spawn

After every spawn, spawnRate is reduced so that monsters come out even faster until they're coming out every single turn. Tweaking spawnRate will have a massive impact on the game's design.

One more rough edge to smooth out. Monsters can spawn right next to us and immediately start attacking. And it's also very weird to see monsters spawning in the middle of the map with no explanation.

We can add a short delay, equivalent to Magic's "summoning sickness", and a little interim sprite to handle this.  It'll be useful when doing any sort of teleport spells too.

[DRAW TELEPORT SPRITE]

---------------------------------- monster.js
class Monster{
	constructor(tile, sprite, hp){
		this.move(tile);
		this.sprite = sprite;
		this.hp = hp;
		this.teleportCounter = 2;												//ADD
	}

	draw(){
		if(this.teleportCounter > 0){											//ADD
			drawSprite(11, this.tile.x, this.tile.y);							//ADD
		}else{																	//ADD
			drawSprite(this.sprite, this.tile.x, this.tile.y);
			this.drawHp();
		}																		//ADD
	}

...

	update(){
		this.teleportCounter--;													//ADD
		if(this.teleportCounter > 0 || this.stunned){							//MODIFY
			this.stunned = false;
			return;
		}
		this.doStuff();
	}

...

class Player extends Monster{
	constructor(tile){
		super(tile, 0, 3);
		this.isPlayer = true;
		this.teleportCounter = 0;												//ADD
	}
----------------------------------

This counter pattern should be pretty familiar since we just looked at spawnCounter. You can do a hell of a lot of work with only boolean flags for statuses and integer counters for longer lasting effects.

The monsters are teleporting in and spawning nicely... eventually leading to an unwillable scenario. Let's give the player an exit from this situation. Literally an Exit tile.

---------------------------------- tile.js
class Floor extends Tile{
	constructor(x,y){
		super(x,y, 2, true);
	};

	stepOn(monster){															//ADD
		//TODO: complete
	}
}

...


class Exit extends Tile{
	constructor(x, y){
		super(x, y, 4, true);
	}

	stepOn(monster){
		if(monster.isPlayer){
			if(level == numLevels){
				showTitle();
			}else{
				level++;
				startLevel(Math.min(maxHp, player.hp+1));
			}
		}
	}
}
----------------------------------

So this is a pretty basic tile with the addition of a stepOn function. You can use such a function to trigger some event (like traps) every time a monster steps on a tile. Notice that we need an empty stepOn() method for Floor too because monsters will be stepping on them. We'll never need it for Walls because monsters don't step on those tiles. And unlike in other languages we don't need it on the base object in order to call it on the subclasses.

If we were already on the last level, we jump to the title screen. Otherwise, we start a new level with 1 extra HP.

---------------------------------- monster.js
move(tile){
	if(this.tile){
		this.tile.monster = null;
	}
	this.tile = tile;
	tile.monster = this;
	tile.stepOn(this);														//ADD
}
----------------------------------


---------------------------------- game.js
function startLevel(playerHp){
	spawnRate = 10;
	spawnCounter = spawnRate;

	generateLevel();

	player = new Player(randomPassableTile());
	player.hp = playerHp;

	randomPassableTile().replace(Exit);										//ADD
}
----------------------------------

With these small additions, the game has some real structure to it.


The title screen is seriously lacking though. I don't want to do anything too crazy for the title screen, but at the very least it needs some text.

If you're trying to draw UI elements for a browser game, I would typically recommend trying it with HTML. You've got a lot of functionality with HTML & CSS, built up over decades. But for a few simple lines of text, the canvas will do.

Drawing text on the canvas is not much different from drawing images. The important bit here is at the end: ctx.fillText. We pass a string and X and Y coordinates. 


---------------------------------- game.js
function drawText(text, size, centered, textY, color){
	ctx.fillStyle = color;
	ctx.font = size+"px monospace";
	let textX;
	if(centered){
		textX = (canvas.width-ctx.measureText(text).width)/2;
	}else{
		textX = canvas.width-uiWidth*tileSize+25;
	}

	ctx.fillText(text, textX, textY);
}
---------------------------------- 

The first two lines set the font color and size. We're going to leave the Y position up to the caller, but to make things easier this function will handle X. We're going to draw text in two places basically: justified centered on the title screen and on the far right during play. The *centered* variable lets us toggle between these two.

So what does this line mean exactly? 

textX = (canvas.width-ctx.measureText(text).width)/2;

[diagram of centering]

When we want to center any element horizontally, whether on the canvas or in HTML, the calculation is the same. Since the coordinates we specify are the top left corner of the element, we can't simply calculate the center of the screen. We start in the center and need to offset the element by half it's width. So that's what we end up with: half the canvas width minus half the text width.

This is a good example of where HTML & CSS would be a lot easier. For one there are many easy ways to center things in CSS and for two getting the width or height of an HTML element is trivial. None of this measureText ugliness. What's worse is there is no corresponding way to measure text *height*!

Anyway, enough ranting... let's draw some text.


---------------------------------- game.js
function draw(){
	if(gameState == "running" || gameState == "dead"){
		ctx.clearRect(0,0,canvas.width,canvas.height);

		for(let i=0;i<numTiles;i++){
			for(let j=0;j<numTiles;j++){
				tiles[i][j].draw();
		    }
		}
		
		for(let k=monsters.length-1;k>=0;k--){
			monsters[k].draw();
		}
		player.draw();

		drawText("Level: "+level, 30, false, 40, "violet");					//ADD
	}
}

...

function showTitle(){
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

	drawText("SUPER", 40, true, canvas.height/2 - 110, "white");			//ADD
	drawText("BROUGH BROS.", 70, true, canvas.height/2 - 50, "white");		//ADD

	gameState = "title";
}
---------------------------------- 

To review the arguments to our drawText function: a string, a font size, whether the text is centered, the Y position, and the color. Whew! That's a mouthful, but it's preventing us from duplicating a lot of code.

We're drawing the level number on the UI during play and drawing the name of the game on the title screen. I chose a silly name. I'm sure you can do better.

At this point it becomes apparent our light green background isn't working out. Let's change it to something dark.

---------------------------------- index.html
<style>
	canvas{
		outline: 1px solid white;
	}

	body{
		background-color: #251323;											//UPDATE
		text-align: center;
		margin: 50px;
	}
</style> 
----------------------------------

Looking good. At this point, the game can be considered a fully playable and complete game. It's just not very interesting yet. We'll get there.

In the next section we'll add treasure and score mechanics.