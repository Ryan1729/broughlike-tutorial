Animation, Screenshake, & Sounds

Turn based movement without animation is not only a bit boring, but it also makes deciphering gameplay difficult. Monsters jump all over the screen and it's impossible to tell exactly what's happening when identical monsters are next to each other.

Luckily, smoothing turn based movement is a piece of cake. When a monster moves from one tile to another, we start out by drawing them immediately in the new tile BUT with an offsetX and offsetY that represents the gap between the old and new position. So for the very first instant after movement, the offsets make the monster appear to be at their old tile, even though their "official" position is at their new tile.

Each frame, we reduce the offsets and in doing so, the sprites slide into place. When the offsets reach 0, sprites appear precisely at the their actual position.

---------------------------------- monster.js
class Monster{
	constructor(tile, sprite, hp){
		this.move(tile);
		this.sprite = sprite;
		this.hp = hp;
		this.teleportCounter = 2;
		this.offsetX = 0;															//ADD
		this.offsetY = 0;															//ADD
	}

	...

	move(tile){
		if(this.tile){
			this.tile.monster = null;

			this.offsetX = this.tile.x - tile.x;									//ADD
			this.offsetY = this.tile.y - tile.y;									//ADD
		}
		this.tile = tile;
		tile.monster = this;
		tile.stepOn(this);
	}
----------------------------------

We initialize the offsets to 0 and then when moving, we calculate them as the difference between the old tile and the new tile position. Say you move to the right 1 tile. You've moved +1 in the X direction, so this code will set the offset to -1. That way you'll start out being drawn to the LEFT of your new tile position.

Here's the code that animates these offsets.

---------------------------------- monster.js
	getDisplayX(){																	//ADD
		return this.tile.x + this.offsetX;
	}

	getDisplayY(){																	//ADD
		return this.tile.y + this.offsetY;
	}	

	draw(){
		if(this.teleportCounter > 0){								
			drawSprite(11, this.getDisplayX(),  this.getDisplayY());				//UPDATE
		}else{																
			drawSprite(this.sprite, this.getDisplayX(),  this.getDisplayY());		//UPDATE
			this.drawHp();
		}

		this.offsetX -= Math.sign(this.offsetX)*(1/8);								//ADD
		this.offsetY -= Math.sign(this.offsetY)*(1/8);								//ADD
	}

	drawHp(){
		for(let i=0;i<this.hp;i++){
			drawSprite(
				10,
				this.getDisplayX() + (i%3)*(5/16),									//UPDATE
				this.getDisplayY() - Math.floor(i/3)*(5/16)							//UPDATE	
			);
		}
	}
----------------------------------

We're writing convenience functions getDisplayX and getDisplayY to get the monster's *apparent* position instead of their official one. Then we're just replacing instances of this.tile.x with getDisplayX() and this.tile.y with getDisplayY();

During each draw call, we're also reducing the value of the offsets by one eigth of a tile, which is what produces the sliding animation. Math.sign() produces either -1, 0, or +1 if passed a negative, zero, or positive number respectively. This lets us move in the correct direction if the offset is still non-zero and completely stop altering the offset if it is zero.

Something interesting to note here is this actually won't work with a value like 0.1 instead of 0.125 (i.e. 1/8) because of floating point math. If you type "0.1+0.1+0.1" into the console instead of 0.3 you'll get "0.30000000000000004". Floating point numbers can only be represented precisely if they are powers of two (e.g. 1/2, 1/4, 1/8). Obviously we could have written this to accomodate any kind of number with more code, but it's nice to do it all in only two lines.

With that, basic animation between tiles is in place. With just two extra lines we can add a bump attack animation.

---------------------------------- monster.js
	tryMove(dx, dy){
		const newTile = this.tile.getNeighbor(dx,dy);
		if(newTile.passable){
			if(!newTile.monster){
				this.move(newTile);
			}else{
				if(this.isPlayer != newTile.monster.isPlayer){
					this.attackedThisTurn = true;
					newTile.monster.stunned = true;
					newTile.monster.hit(1);

					this.offsetX = (newTile.x - this.tile.x)/2;						//ADD
					this.offsetY = (newTile.y - this.tile.y)/2;						//ADD
				}
			}
			return true;
		}
	}
----------------------------------

When bump attacking, monsters are not really moving between tiles. Instead we're setting their offset so that the moment after attack they'll appear partially *in* the tile they're attacking. That's why we divided by 2. We want the monster to look like they've jumped halfway into their opponent's tile to give them a wallop.

SCREENSHAKE

Screenshake uses a similar concept to offset animation: draw things in their proper place and then just tack on some additional offsets. And also reduce the value of those offsets every frame until they're 0 (the screenshake should quickly fade out).

In the case of screenshake, the offsets are random and they will apply to *everything* on screen. This lets us do our screenshake offset in a single place: drawSprite.

[drawing of the shake radius]

We'll start out declaring a shakeAmount variable for the magnitude of the shake and two component variables shakeX and shakeY. All are assigned 0 because we don't want to start out shaking.


---------------------------------- index.html
<script>
	const maxHp = 6; 
	const startingHp = 3;
	const numLevels = 6;

	const tileSize = 64;
	const numTiles = 11;
	const uiWidth = 4;

	let level = 1;
	let gameState = "loading";
	let player;

	let shakeAmount = 0;															//ADD
	let shakeX = 0;																	//ADD
	let shakeY = 0;																	//ADD

	let spritesheet = new Image();
----------------------------------

After each monster hit, we add some shake.

---------------------------------- monster.js
tryMove(dx, dy){
	const newTile = this.tile.getNeighbor(dx,dy);
	if(newTile.passable){
		if(!newTile.monster){
			this.move(newTile);
		}else{
			if(this.isPlayer != newTile.monster.isPlayer){
				this.attackedThisTurn = true;
				newTile.monster.stunned = true;
				newTile.monster.hit(1);

				shakeAmount = 5;													//ADD

				this.offsetX = (newTile.x - this.tile.x)/2;
				this.offsetY = (newTile.y - this.tile.y)/2;
			}
		}
		return true;
	}
}
---------------------------------- 

In game.js, we're going to add a new screenshake method that will handle splitting out screenAmount into X & Y components and damping the amount.

The part that actually affects what you see is in drawSprite. We're adding the X & Y components to the destination X & Y coordinates.

---------------------------------- game.js
function drawSprite(sprite, x, y){
	ctx.drawImage(
		spritesheet,
		sprite*16,
		0,
		16,
		16,
		x*tileSize + shakeX,														//MODIFY
		y*tileSize + shakeY,														//MODIFY
		tileSize,
		tileSize
	);
}

function draw(){
	if(gameState == "running" || gameState == "dead"){
		ctx.clearRect(0,0,canvas.width,canvas.height);

		screenshake();																//ADD

...

function screenshake(){
	if(shakeAmount){
		shakeAmount--;
	}
	let shakeAngle = Math.random()*Math.PI*2;
	shakeX = Math.round(Math.cos(shakeAngle)*shakeAmount);
	shakeY = Math.round(Math.sin(shakeAngle)*shakeAmount);
}
----------------------------------

The shakeAmount is reduced by 1 if it's not already 0. We select a random angle and then use Math.cos and Math.sin to find the X & Y components of that angle. We multiply by the amount and finally round off to ensure there is no sub-pixel nonsense going on (that can look really bad).

Our screenshake is pretty subtle, but for fun try setting the shakeAmount on hit to a ridiculously high amount like 50 or higher and see what happens.

SOUNDS

[go make all sounds on bfxr.net]

We're going to make 5 sounds:

-hit1.wav: when the player hits a monster
-hit2:wav: when a monster hits the player
-treasure.wav: when the player picks up a treasure
-newLevel: when the player exits a level
-spell: when a player casts a spell

[place all sounds in sounds folder]

The Audio object in JavaScript is very easy to use. The minimum you need is to create a new Audio object passing the audio URL and then call play() on it.

We'll add a little extra code to abstract playing different sounds since we have 5 of them.

---------------------------------- index.html
	setupCanvas();

	initSounds();																	//ADD

	setInterval(draw, 15);
</script>
----------------------------------


---------------------------------- game.js
function initSounds(){																//ADD
	sounds = {
		hit1: new Audio('sounds/hit1.wav'),
		hit2: new Audio('sounds/hit2.wav'),
		treasure: new Audio('sounds/treasure.wav'),
		newLevel: new Audio('sounds/newLevel.wav'),
		spell: new Audio('sounds/spell.wav'),
	};
}

function playSound(soundName){														//ADD
	sounds[soundName].currentTime = 0;	
	sounds[soundName].play();
}
----------------------------------

We immediately call initSounds to load our 5 sounds and store them in a global object called sounds. To play a sound, we call playSound with the desired sound name. The only oddity is currentTime. Without resetting this to 0, trying to play a sound that's already in the progress of playing (like hitting a bunch of enemies quickly) sounds terrible.

Now let's call playSound in 4 places (the "spell" sound will be covered in the next section):

---------------------------------- monster.js
hit(damage){
	this.hp -= damage;
	if(this.hp <= 0){
		this.die();
	}

	if(this.isPlayer){																//ADD			
		playSound("hit1");															//ADD
	}else{																			//ADD
		playSound("hit2");															//ADD
	}																				//ADD
}
---------------------------------- 


---------------------------------- tile.js
class Floor extends Tile{
	constructor(x,y){
		super(x,y, 2, true);
	};

	stepOn(monster){
		if(monster.isPlayer && this.treasure){
			score++;
			playSound("treasure");													//ADD		
			this.treasure = false;
			spawnMonster();
		}
	}
}

...

class Exit extends Tile{
	constructor(x, y){
		super(x, y, 4, true);
	}

	stepOn(monster){
		if(monster.isPlayer){
			playSound("newLevel");													//ADD
			if(level == numLevels){
				addScore(score, true);
				showTitle();
			}else{
				level++;
				startLevel(Math.min(maxHp, player.hp+1));
			}
		}
	}
}
----------------------------------

Now the game is really starting to look and sound like something nice. For our last addition, we'll add spells in the next section.