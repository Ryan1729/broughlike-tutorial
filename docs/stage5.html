<!DOCTYPE html>
<html>
<head>
	<title>Broughlike tutorial - Stage 5</title>
	<meta charset="utf-8">
</head>
<body>
	<div id="outer">
		<h1>Stage 5: Game Lifecycle: drawing text, title screen, failure condition, and moving between levels</h1>
        Currently, when monsters are killed they are immediately deleted from the game. That's great, but there is no code to handle <em>player</em> death. Let's tackle that now.
        <h2>Game state</h2>
        We'll add the concept of a 
        <div class="code-container-inline inline"><pre><code class="javascript">gameState</code></pre></div>
        so we can model the game as a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machine</a> with four states.
        <br><br>
        Our four states:
        <ul>
            <li><strong>loading</strong>: waiting for the assets to load</li> 
            <li><strong>title</strong>: on the title screen</li> 
            <li><strong>running</strong>: playing the game actively</li> 
            <li><strong>dead</strong>: the moment after the player has died, but before returning to the title screen</li> 
        </ul>
        "Finite state machine" sounds super complicated. It's not.
        <img src="screens/state-machine.png">
        Just think about a title screen. That's a state. Then when the <em>actual game</em> is running, that's a state. Clearly different things are displayed on the title screen versus the game proper. And pressing a specific button in-game and pressing it on the title screen do different things. So that's all we're trying to accomplish.
        <br><br>
        To make this work, we need to only do two things.
        <ol>
            <li>When needed, switch states simply by setting <div class="code-container-inline inline"><pre><code class="javascript">gameState</code></pre></div> to a different state name</li>
            <li>Use conditionals checking the value of <div class="code-container-inline inline"><pre><code class="javascript">gameState</code></pre></div> to wrap behavior that should only occur in specific states</li>
            
        </ol>
        <div class="filename">index.html</div>
        <div class="code-container">
            <pre><code id="contentLOADING1" class="javascript"></code></pre>
            <pre><code id="contentLOADING2" class="javascript add"></code></pre>
            <pre><code id="contentLOADING3" class="javascript"></code></pre>
            <pre><code id="contentLOADING4" class="javascript add"></code></pre>
            <pre><code id="contentLOADING5" class="javascript"></code></pre>
            <pre><code id="contentLOADING6" class="javascript add"></code></pre>
            <pre><code id="contentLOADING7" class="javascript"></code></pre>
            <pre><code id="contentLOADING8" class="javascript remove"></code></pre>
            <pre><code id="contentLOADING9" class="javascript add"></code></pre>
            <pre><code id="contentLOADING10" class="javascript"></code></pre>
        </div>

        When our spritesheet image loads, we want to switch to showing the title screen which is accomplished by assigning a function to
        <div class="code-container-inline inline"><pre><code class="javascript">spritesheet.onload</code></pre></div>
        (we'll write that 
        <div class="code-container-inline inline"><pre><code class="javascript">showTitle</code></pre></div>
        function below next). But what's our first state? Unsurprisingly, we're initializing 
        <div class="code-container-inline inline"><pre><code class="javascript">gameState</code></pre></div>
        to "loading" because that's the first thing that happens. 
        <br><br>
        While we're here, we're adding some variables related to the game lifecycle: 
        <div class="code-container-inline inline"><pre><code class="javascript">startingHp</code></pre></div>
        and
        <div class="code-container-inline inline"><pre><code class="javascript">numLevels</code></pre></div>.
        <br><br>
        Within the  
        <div class="code-container-inline inline"><pre><code class="javascript">onkeypress</code></pre></div>
        handler, you can see where we're starting to add transitions between game states when buttons are pressed and also restricting when gameplay actions can take place (only when "running").
        <br><br>
        Lastly, we're moving out some code related to setting the
        <div class="code-container-inline inline"><pre><code class="javascript">player</code></pre></div>
        location and generating a level. If we're going to have multiple levels, it no longer makes sense to do these things only once.
        <br><br>

        There are several small changes to add to game.js:

        <div class="filename">game.js</div>
        <div class="code-container">
            <pre><code id="contentDRAW1" class="javascript"></code></pre>
            <pre><code id="contentDRAW2" class="javascript add"></code></pre>
            <pre><code id="contentDRAW3" class="javascript"></code></pre>
            <pre><code id="contentDRAW4" class="javascript add"></code></pre>
            <pre><code id="contentCLOSINGBRACE" class="javascript"></code></pre>
            <pre><code id="contentNEWLINE" class="javascript"></code></pre>
            <pre><code id="contentTICK1" class="javascript"></code></pre>
            <pre><code id="contentTICK2" class="javascript add"></code></pre>
            <pre><code id="contentCLOSINGBRACE" class="javascript"></code></pre>
            <pre><code id="contentNEWLINE" class="javascript"></code></pre>
            <pre><code id="contentSHOWTITLE" class="javascript add"></code></pre>
        </div>
        In 
        <div class="code-container-inline inline"><pre><code class="javascript">draw</code></pre></div>,
        we restrict our draw operations to when the game is running OR when the player just died.
        <br><br>
        In 
        <div class="code-container-inline inline"><pre><code class="javascript">tick</code></pre></div>,
        we change to the "dead" state when we detect that the player has died.
        <br><br>
        In 
        <div class="code-container-inline inline"><pre><code class="javascript">showTitle</code></pre></div>,
        we draw a semi-transparent black background, which will function as our title screen for now. Then we change to the "title" state.
        <br><br>
        In 
        <div class="code-container-inline inline"><pre><code class="javascript">startGame</code></pre></div>,
        we jump to the first floor, call <div class="code-container-inline inline"><pre><code class="javascript">startLevel</code></pre></div>, and we change to the "dead" state.
        <br><br>
        In 
        <div class="code-container-inline inline"><pre><code class="javascript">startLevel</code></pre></div>,
        we generate our level and set up the <div class="code-container-inline inline"><pre><code class="javascript">player</code></pre></div>. The <div class="code-container-inline inline"><pre><code class="javascript">player</code></pre></div> gets initalized with 
        <div class="code-container-inline inline"><pre><code class="javascript">hp</code></pre></div>
         equal to the value passed in 
        <div class="code-container-inline inline"><pre><code class="javascript">playerHp</code></pre></div>. This value starts as 3, but in a little bit we'll use this function to persist player HP across levels.
        <br><br>
        Now load up the game. You'll see the "title screen", a black box for now. When you hit a key, the game will start running. And if you were to die, everything would freeze until you pressed another key... leading back to the title screen, this time overlaid semitransparently over the game. That's the whole state machine right there working!
        <h2>Spawning more monsters</h2>
        It's not easy to die in this game. No monsters spawn after the first two. Let's make it harder.

        <div class="filename">game.js</div>
        <div class="code-container">
            <pre><code id="contentTICK1" class="javascript"></code></pre>
            <pre><code id="contentTICK2" class="javascript"></code></pre>
            <pre><code id="contentNEWLINE" class="javascript"></code></pre>
            <pre><code id="contentSPAWN1" class="javascript add"></code></pre>
            <pre><code id="contentCLOSINGBRACE" class="javascript"></code></pre>
            <pre><code class="break">...</code></pre>
            <pre><code id="contentSPAWN2" class="javascript"></code></pre>
            <pre><code id="contentSPAWN3" class="javascript add"></code></pre>
            <pre><code id="contentSPAWN4" class="javascript"></code></pre>
        </div>
        <!--

----------------------------------
function tick(){
    for(let k=monsters.length-1;k>=0;k--){
        if(!monsters[k].dead){
            monsters[k].update();
        }else{
            monsters.splice(k,1);
        }
    }

    if(player.dead){
        gameState = "dead";
    }

    spawnCounter-=2;                                                                //ADD
    if(spawnCounter <= 0){                                                      //ADD       
        spawnMonster();
        spawnCounter = spawnRate;
        spawnRate--;
    }
}

...

function startLevel(playerHp){
    spawnRate = 22;                                                             //ADD
    spawnCounter = spawnRate;                                                   //ADD

    generateLevel();

    player = new Player(randomPassableTile());
    player.hp = playerHp;
}
----------------------------------

We're using two new global variables here.

-spawnRate is how often monsters will get spawned
-spawnCounter counts down until the new spawn

After every spawn, spawnRate is reduced so that monsters come out even faster until they're coming out every single turn. Tweaking spawnRate will have a massive impact on the game's design.

One more rough edge to smooth out. Monsters can spawn right next to us and immediately start attacking. And it's also very weird to see monsters spawning in the middle of the map with no explanation.

We can add a short delay, equivalent to Magic's "summoning sickness", and a little interim sprite to handle this.  It'll be useful when doing any sort of teleport spells too.

TODO: ADD TICK() IN START LEVEL

[DRAW TELEPORT SPRITE]

---------------------------------- monster.js
class Monster{
    constructor(tile, sprite, hp){
        this.move(tile);
        this.sprite = sprite;
        this.hp = hp;
        this.teleportCounter = 2;                                               //ADD
    }

    draw(){
        if(this.teleportCounter > 0){                                           //ADD
            drawSprite(11, this.tile.x, this.tile.y);                           //ADD
        }else{                                                                  //ADD
            drawSprite(this.sprite, this.tile.x, this.tile.y);
            this.drawHp();
        }                                                                       //ADD
    }

...

    update(){
        this.teleportCounter--;                                                 //ADD
        if(this.teleportCounter > 0 || this.stunned){                           //MODIFY
            this.stunned = false;
            return;
        }
        this.doStuff();
    }

...

class Player extends Monster{
    constructor(tile){
        super(tile, 0, 3);
        this.isPlayer = true;
        this.teleportCounter = 0;                                               //ADD
    }
----------------------------------

This counter pattern should be pretty familiar since we just looked at spawnCounter. You can do a hell of a lot of work with only boolean flags for statuses and integer counters for longer lasting effects.

The monsters are teleporting in and spawning nicely... eventually leading to an unwillable scenario. Let's give the player an exit from this situation. Literally an Exit tile.

---------------------------------- tile.js
class Floor extends Tile{
    constructor(x,y){
        super(x,y, 2, true);
    };

    stepOn(monster){                                                            //ADD
        //TODO: complete
    }
}

...


class Exit extends Tile{
    constructor(x, y){
        super(x, y, 4, true);
    }

    stepOn(monster){
        if(monster.isPlayer){
            if(level == numLevels){
                showTitle();
            }else{
                level++;
                startLevel(Math.min(maxHp, player.hp+1));
            }
        }
    }
}
----------------------------------

So this is a pretty basic tile with the addition of a stepOn function. You can use such a function to trigger some event (like traps) every time a monster steps on a tile. Notice that we need an empty stepOn() method for Floor too because monsters will be stepping on them. We'll never need it for Walls because monsters don't step on those tiles. And unlike in other languages we don't need it on the base object in order to call it on the subclasses.

If we were already on the last level, we jump to the title screen. Otherwise, we start a new level with 1 extra HP.

---------------------------------- monster.js
move(tile){
    if(this.tile){
        this.tile.monster = null;
    }
    this.tile = tile;
    tile.monster = this;
    tile.stepOn(this);                                                      //ADD
}
----------------------------------


---------------------------------- game.js
function startLevel(playerHp){
    spawnRate = 10;
    spawnCounter = spawnRate;

    generateLevel();

    player = new Player(randomPassableTile());
    player.hp = playerHp;

    randomPassableTile().replace(Exit);                                     //ADD
}
----------------------------------

With these small additions, the game has some real structure to it.


The title screen is seriously lacking though. I don't want to do anything too crazy for the title screen, but at the very least it needs some text.

If you're trying to draw UI elements for a browser game, I would typically recommend trying it with HTML. You've got a lot of functionality with HTML & CSS, built up over decades. But for a few simple lines of text, the canvas will do.

Drawing text on the canvas is not much different from drawing images. The important bit here is at the end: ctx.fillText. We pass a string and X and Y coordinates. 


---------------------------------- game.js
function drawText(text, size, centered, textY, color){
    ctx.fillStyle = color;
    ctx.font = size+"px monospace";
    let textX;
    if(centered){
        textX = (canvas.width-ctx.measureText(text).width)/2;
    }else{
        textX = canvas.width-uiWidth*tileSize+25;
    }

    ctx.fillText(text, textX, textY);
}
---------------------------------- 

The first two lines set the font color and size. We're going to leave the Y position up to the caller, but to make things easier this function will handle X. We're going to draw text in two places basically: justified centered on the title screen and on the far right during play. The *centered* variable lets us toggle between these two.

So what does this line mean exactly? 

textX = (canvas.width-ctx.measureText(text).width)/2;

[diagram of centering]

When we want to center any element horizontally, whether on the canvas or in HTML, the calculation is the same. Since the coordinates we specify are the top left corner of the element, we can't simply calculate the center of the screen. We start in the center and need to offset the element by half it's width. So that's what we end up with: half the canvas width minus half the text width.

This is a good example of where HTML & CSS would be a lot easier. For one there are many easy ways to center things in CSS and for two getting the width or height of an HTML element is trivial. None of this measureText ugliness. What's worse is there is no corresponding way to measure text *height*!

Anyway, enough ranting... let's draw some text.


---------------------------------- game.js
function draw(){
    if(gameState == "running" || gameState == "dead"){
        ctx.clearRect(0,0,canvas.width,canvas.height);

        for(let i=0;i<numTiles;i++){
            for(let j=0;j<numTiles;j++){
                tiles[i][j].draw();
            }
        }
        
        for(let k=monsters.length-1;k>=0;k--){
            monsters[k].draw();
        }
        player.draw();

        drawText("Level: "+level, 30, false, 40, "violet");                 //ADD
    }
}

...

function showTitle(){
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    drawText("SUPER", 40, true, canvas.height/2 - 110, "white");            //ADD
    drawText("BROUGH BROS.", 70, true, canvas.height/2 - 50, "white");      //ADD

    gameState = "title";
}
---------------------------------- 

To review the arguments to our drawText function: a string, a font size, whether the text is centered, the Y position, and the color. Whew! That's a mouthful, but it's preventing us from duplicating a lot of code.

We're drawing the level number on the UI during play and drawing the name of the game on the title screen. I chose a silly name. I'm sure you can do better.

At this point it becomes apparent our light green background isn't working out. Let's change it to something dark.

---------------------------------- index.html
<style>
    canvas{
        outline: 1px solid white;
    }

    body{
        background-color: #251323;                                          //UPDATE
        text-align: center;
        margin: 50px;
    }
</style> 
----------------------------------

Looking good. At this point, the game can be considered a fully playable and complete game. It's just not very interesting yet. We'll get there.

In the next section we'll add treasure and score mechanics.
        -->
	</div>

	<script>
		let content = {
			LOADING1:
            `
<script> 
    let tileSize = 64;
    let numTiles = 11;
    let uiWidth = 4;
    let level = 1;
    let maxHp = 6;

    let spritesheet = new Image();
    spritesheet.src = 'spritesheet.png';
            `,
            LOADING2:
            `
    spritesheet.onload = showTitle;
                             
    let gameState = "loading";  

    let startingHp = 3; 
    let numLevels = 6;          
            `,
            LOADING3:
            `

    document.querySelector("html").onkeypress = function(e){
            `,
            LOADING4:
            `
        if(gameState == "title"){                              
            startGame();                
        }else if(gameState == "dead"){                             
            showTitle();                                        
        }else if(gameState == "running"){                                               
            `,
            LOADING5:
            `
            if(e.which==119) player.tryMove(0,-1);
            if(e.which==115) player.tryMove(0,1);
            if(e.which==97) player.tryMove(-1, 0);
            if(e.which==100) player.tryMove(1, 0);
            `,
            LOADING6:
            `
        }
            `,
            LOADING7:
            `
    };

    setInterval(draw, 20);

    setupCanvas();

            `,
            LOADING8:
            `
    generateLevel();                

    let player = new Player(randomPassableTile());               
            `,
            LOADING9:
            `
    let player;
            `,
            LOADING10:
            `  
<\/script>
            `,
            DRAW1:
            `
function draw(){
            `,
            DRAW2:
            `
    if(gameState == "running" || gameState == "dead"){  
            `,
            DRAW3:
            `
        ctx.clearRect(0,0,canvas.width,canvas.height);

        for(let i=0;i<numTiles;i++){
            for(let j=0;j<numTiles;j++){
                getTile(i,j).draw();
            }
        }


        for(let i=0;i<monsters.length;i++){
            monsters[i].draw();
        }

        player.draw();
            `,
            DRAW4:
            `
    }
            `,
            CLOSINGBRACE:
            `
}
            `,
            NEWLINE:
            `

            `,
            TICK1:
            `
function tick(){
    for(let k=monsters.length-1;k>=0;k--){
        if(!monsters[k].dead){
            monsters[k].update();
        }else{
            monsters.splice(k,1);
        }
    }

            `,
            TICK2:
            `
    if(player.dead){    
        gameState = "dead";
    }
            `,
            SHOWTITLE:
            `
function showTitle(){                                          
    ctx.fillStyle = 'rgba(0,0,0,.75)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    gameState = "title";
}

function startGame(){                                           
    level = 1;
    startLevel(startingHp);

    gameState = "running";
}

function startLevel(playerHp){                          
    generateLevel();

    player = new Player(randomPassableTile());
    player.hp = playerHp;
}
            `,
            SPAWN1:
            `
    spawnCounter-=2;
    if(spawnCounter <= 0){  
        spawnMonster();
        spawnCounter = spawnRate;
        spawnRate--;
    }
            `,
            SPAWN2:
            `

function startLevel(playerHp){ 
            `,
            SPAWN3:
            `
    spawnRate = 22;              
    spawnCounter = spawnRate;                      
            `,
            SPAWN4:
            `

    generateLevel();

    player = new Player(randomPassableTile());
    player.hp = playerHp;
}
            `


            // should startGame have tick() before gameState = "running";

		};
	</script>

	<link rel="stylesheet" href="highlight.min.css">
	<link rel="stylesheet" href="style.css">
	<script src="highlight.min.js"></script>
	<script src="diff.js"></script>
</body>
</html>